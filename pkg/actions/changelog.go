package actions

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// ChangelogAction generates and updates changelogs using schangelog.
type ChangelogAction struct{}

// Name returns the action name.
func (a *ChangelogAction) Name() string {
	return "changelog"
}

// Run executes the changelog action directly.
func (a *ChangelogAction) Run(dir string, opts Options) Result {
	// Check if schangelog is available
	if !commandExists("schangelog") {
		return Result{
			Name:    "changelog",
			Success: false,
			Error:   fmt.Errorf("schangelog not found in PATH"),
			Output:  "Install schangelog: go install github.com/grokify/schangelog/cmd/schangelog@latest",
		}
	}

	// Determine the since tag
	since := opts.Since
	if since == "" {
		// Try to get the latest tag
		latestTag, err := getLatestTag(dir)
		if err != nil {
			return Result{
				Name:    "changelog",
				Success: false,
				Error:   err,
				Output:  "Could not determine latest tag. Use --since to specify.",
			}
		}
		since = latestTag
	}

	var output strings.Builder

	// Step 1: Parse commits
	output.WriteString(fmt.Sprintf("Parsing commits since %s...\n", since))
	parseArgs := []string{"parse-commits", "--since=" + since, "--format=toon"}
	parseResult := runCommand("parse-commits", dir, "schangelog", parseArgs...)
	if !parseResult.Success {
		return Result{
			Name:    "changelog",
			Success: false,
			Error:   parseResult.Error,
			Output:  parseResult.Output,
		}
	}
	output.WriteString(parseResult.Output)
	output.WriteString("\n")

	// If dry run, stop here
	if opts.DryRun {
		output.WriteString("\n[Dry run] Would generate changelog from commits above\n")
		return Result{
			Name:    "changelog",
			Success: true,
			Output:  output.String(),
		}
	}

	// Step 2: Check if CHANGELOG.json exists
	changelogJSON := filepath.Join(dir, "CHANGELOG.json")
	if !fileExists(changelogJSON) {
		output.WriteString("\nCHANGELOG.json not found. Create it first or use schangelog init.\n")
		return Result{
			Name:    "changelog",
			Success: false,
			Output:  output.String(),
		}
	}

	// Step 3: Validate existing CHANGELOG.json
	output.WriteString("\nValidating CHANGELOG.json...\n")
	validateResult := runCommand("validate", dir, "schangelog", "validate", "CHANGELOG.json")
	if !validateResult.Success {
		return Result{
			Name:    "changelog",
			Success: false,
			Error:   validateResult.Error,
			Output:  output.String() + validateResult.Output,
		}
	}
	output.WriteString("CHANGELOG.json is valid\n")

	// Step 4: Generate CHANGELOG.md
	output.WriteString("\nGenerating CHANGELOG.md...\n")
	generateResult := runCommand("generate", dir, "schangelog", "generate", "CHANGELOG.json", "-o", "CHANGELOG.md")
	if !generateResult.Success {
		return Result{
			Name:    "changelog",
			Success: false,
			Error:   generateResult.Error,
			Output:  output.String() + generateResult.Output,
		}
	}
	output.WriteString("Generated CHANGELOG.md\n")

	return Result{
		Name:    "changelog",
		Success: true,
		Output:  output.String(),
	}
}

// Propose generates proposals for interactive mode.
func (a *ChangelogAction) Propose(dir string, opts Options) ([]Proposal, error) {
	// Check if schangelog is available
	if !commandExists("schangelog") {
		return nil, fmt.Errorf("schangelog not found in PATH")
	}

	// Determine the since tag
	since := opts.Since
	if since == "" {
		latestTag, err := getLatestTag(dir)
		if err != nil {
			return nil, fmt.Errorf("could not determine latest tag: %w", err)
		}
		since = latestTag
	}

	// Parse commits to show what would be included
	parseArgs := []string{"parse-commits", "--since=" + since, "--format=toon"}
	parseResult := runCommand("parse-commits", dir, "schangelog", parseArgs...)
	if !parseResult.Success {
		return nil, fmt.Errorf("failed to parse commits: %w", parseResult.Error)
	}

	// Read current CHANGELOG.md if it exists
	changelogMD := filepath.Join(dir, "CHANGELOG.md")
	oldContent := ""
	if fileExists(changelogMD) {
		content, err := os.ReadFile(changelogMD)
		if err == nil {
			oldContent = string(content)
		}
	}

	return []Proposal{
		{
			Description: fmt.Sprintf("Update changelog with commits since %s", since),
			FilePath:    "CHANGELOG.md",
			OldContent:  oldContent,
			NewContent:  "[Will be generated by schangelog]",
			Metadata: map[string]string{
				"since":   since,
				"commits": parseResult.Output,
			},
		},
	}, nil
}

// Apply applies approved proposals.
func (a *ChangelogAction) Apply(dir string, proposals []Proposal) Result {
	// Run the action to apply changes
	return a.Run(dir, Options{DryRun: false})
}

// ParseCommits runs schangelog parse-commits and returns the output.
func (a *ChangelogAction) ParseCommits(dir string, since string, format string) (string, error) {
	if !commandExists("schangelog") {
		return "", fmt.Errorf("schangelog not found in PATH")
	}

	if format == "" {
		format = "toon"
	}

	args := []string{"parse-commits", "--since=" + since, "--format=" + format}
	result := runCommand("parse-commits", dir, "schangelog", args...)
	if !result.Success {
		return "", result.Error
	}

	return result.Output, nil
}

// Generate runs schangelog generate to create CHANGELOG.md.
func (a *ChangelogAction) Generate(dir string) error {
	if !commandExists("schangelog") {
		return fmt.Errorf("schangelog not found in PATH")
	}

	result := runCommand("generate", dir, "schangelog", "generate", "CHANGELOG.json", "-o", "CHANGELOG.md")
	if !result.Success {
		return result.Error
	}

	return nil
}

// Validate runs schangelog validate on CHANGELOG.json.
func (a *ChangelogAction) Validate(dir string) error {
	if !commandExists("schangelog") {
		return fmt.Errorf("schangelog not found in PATH")
	}

	result := runCommand("validate", dir, "schangelog", "validate", "CHANGELOG.json")
	if !result.Success {
		return fmt.Errorf("validation failed: %s", result.Output)
	}

	return nil
}

// Helper functions

func commandExists(command string) bool {
	_, err := exec.LookPath(command)
	return err == nil
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func runCommand(name string, dir string, command string, args ...string) Result {
	cmd := exec.Command(command, args...)
	cmd.Dir = dir

	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err := cmd.Run()

	output := stdout.String()
	if stderr.Len() > 0 {
		if output != "" {
			output += "\n"
		}
		output += stderr.String()
	}

	return Result{
		Name:    name,
		Success: err == nil,
		Output:  strings.TrimSpace(output),
		Error:   err,
	}
}

func getLatestTag(dir string) (string, error) {
	cmd := exec.Command("git", "describe", "--tags", "--abbrev=0")
	cmd.Dir = dir

	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("no tags found: %w", err)
	}

	return strings.TrimSpace(string(output)), nil
}
